package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"

	_ "github.com/joho/godotenv/autoload"
	"github.com/notarock/a_c_a_c/pkg/chain"
	"github.com/notarock/a_c_a_c/pkg/config"
	"github.com/notarock/a_c_a_c/pkg/runner"
	"github.com/notarock/a_c_a_c/pkg/twitch"

	"github.com/tmc/langchaingo/llms"
	"github.com/tmc/langchaingo/llms/googleai"
)

var IGNORE_PARROTS = os.Getenv("IGNORE_PARROTS") == "true"
var BASE_PATH = os.Getenv("BASE_PATH")
var TWITCH_USER = os.Getenv("TWITCH_USER")
var TWITCH_OAUTH_STRING = os.Getenv("TWITCH_OAUTH_STRING")
var ENV = os.Getenv("ENV")

var PROHIBITED_STRINGS = strings.Split(os.Getenv("PROHIBITED_STRINGS"), ",")
var PROHIBITED_MESSAGES = strings.Split(os.Getenv("PROHIBITED_MESSAGES"), ",")

var MESSAGE_FILE_PATTERN = "%s/%s.txt"             // BASEPATH-CHANNEL.txt
var SAVED_MESSAGES_FILE_PATTERN = "%s/%s-sent.txt" // BASEPATH-CHANNEL-sent.txt

const GREEN = "\033[32m"
const RED = "\033[31m"
const RESET = "\033[0m"

func main() {
	messagesFile := flag.String("from-file", "", "A file to read messages from and spit out one generated message")
	flag.Parse()

	if *messagesFile != "" {
		message := loadAndGenerate(*messagesFile)
		fmt.Println(message)
		improveWithAI(message)
		os.Exit(0)
	}

	if BASE_PATH == "" || TWITCH_USER == "" || TWITCH_OAUTH_STRING == "" {
		log.Panic("Missing environment variables")
	}

	channelConfig, err := config.LoadChannelConfig(os.Getenv("CHANNEL_CONFIG"))

	if err != nil {
		log.Panic("Error loading channel config:", err)
	}

	var runners []*runner.MessageCountdownRunner

	for _, channel := range channelConfig.Channels {

		savedMessagesFilepath := fmt.Sprintf(MESSAGE_FILE_PATTERN, BASE_PATH, channel.Name)
		sentMessagesFilepath := fmt.Sprintf(SAVED_MESSAGES_FILE_PATTERN, BASE_PATH, channel.Name)

		if ENV != "production" {
			fmt.Println("Environment: ", ENV)
			fmt.Println("Channel: ", GREEN, fmt.Sprintf("%+v", channel), RESET)
			fmt.Println("Base path: ", BASE_PATH)
			fmt.Println("Saving chat messages to: ", savedMessagesFilepath)
			fmt.Println("Saving sent messages to: ", sentMessagesFilepath)
		}

		chain, err := chain.NewChain(chain.ChainConfig{
			Saving:                true,
			IgnoreParrots:         IGNORE_PARROTS,
			SavedMessagesFilepath: savedMessagesFilepath,
			SentMessagesFilepath:  sentMessagesFilepath,
			ProhibitedStrings:     PROHIBITED_STRINGS,
			ProhibitedMessages:    PROHIBITED_MESSAGES,
		})

		if err != nil {
			log.Fatal(err)
		}

		client := twitch.NewClient(twitch.ClientConfig{
			Username: TWITCH_USER,
			OAuth:    TWITCH_OAUTH_STRING,
			Channel:  channel.Name,
			Bots:     append(channelConfig.Bots, channel.ExtraBots...),
			Sending:  ENV == "production",
		})

		r := runner.NewMessageCountdownRunner(runner.MessageCountdownConfig{
			Client:   client,
			Chain:    chain,
			Interval: channel.Frequency,
		})

		runners = append(runners, r)
	}

	for _, runner := range runners {
		go runner.Run()
	}

	select {}
}

func loadAndGenerate(messagesFile string) string {
	chain, err := chain.NewChain(chain.ChainConfig{
		Saving:                false,
		IgnoreParrots:         false,
		SavedMessagesFilepath: messagesFile,
	})
	if err != nil {
		log.Panic(err)
	}

	return chain.FilteredMessage()
}

func improveWithAI(message string) {
	ctx := context.Background()
	apiKey := os.Getenv("GEMINI_API_KEY")
	llm, err := googleai.New(ctx,
		googleai.WithAPIKey(apiKey),
		googleai.WithDefaultModel("gemini-2.0-flash"),
	)
	if err != nil {
		log.Fatal(err)
	}

	prompt := fmt.Sprintf(`
You're given a message that was generated by a Markov chain and may contain gibberish, broken grammar, or unreadable phrasing.

Your task is to clean up the message while preserving:

The original meaning, topic, and context
Any Twitch-specific emotes (e.g., Kappa, PogChamp, LUL) or slang
The natural Twitch chat tone — informal, fast-paced, and expressive
Do not change the subject, add new content, or remove valid emotes. Only fix grammar and phrasing to make the message clearer for human readers.

Important: Do not end the cleaned-up message with a period or any final punctuation mark unless it’s part of an emote or necessary abbreviation.

Return the result in this exact JSON format. Do not include any other character as this must be parsable as valid json directly:

{
	"original": "input message",
	"messageimproved": "cleaned up message"
}

Now clean up the following message:

%s

	`,
		message)

	completionWithoutStreaming, err := llms.GenerateFromSinglePrompt(ctx, llm, prompt)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("\n" + completionWithoutStreaming)
}
